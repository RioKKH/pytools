#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random
from typing import List

import numpy as np
from scipy.special import comb
from nsga3.population import Population
from nsga3.individual import Individual
from nsga3.reference_point import ReferencePoint


class NSGA3Utils:
    """
    This class provids utility functions for the NSGA-III algorithm.
    """

    def __init__(self,
                 problem,
                 num_of_individuals=100,
                 num_of_tour_particips=2,
                 tournament_prob=0.9,
                 crossover_param=2,
                 mutation_param=5,
                 division_num=12):
        """
        Initializes an instance of the NSGA2Utils class

        :param problem: The problem to optimize.
        :param num_of_individuals: The number of individuals (solutions) in each generation.
        :param num_of_tour_particips: The number of participants in tournament selection.
        :param tournament_prob: The probability used in tournament selection.
        :param crossover_param: The parameter used in crossover operation.
        :param mutation_param: The parameter used in mutation operation.
        """

        self.problem = problem
        self.num_of_individuals = num_of_individuals
        self.num_of_tour_particips = num_of_tour_particips
        self.tournament_prob = tournament_prob
        self.crossover_param = crossover_param
        self.mutation_param = mutation_param
        self.reference_points = self.generate_reference_points(problem.num_of_objectives,
                                                               division_num)


    def create_initial_population(self):
        """
        Creates an initial population for the NSGA-II algorithm. Each individual
        in the population is generated by the problem and its objectives are
        calculated.

        :return: The initial population.
        """
        population = Population()
        for _ in range(self.num_of_individuals):
            individual = self.problem.generate_individual()
            self.problem.calculate_objectives(individual)
            population.append(individual)
        return population


    def fast_nondominated_sort(self, population) -> List[List[Individual]]:
        """
        Performs fast non-dominated sort on the population. It calculates the 
        domination count and dominated solutions for each individual, and
        assigns them to different fronts based on their domination count.
        """
        # Initialize the first front
        population.fronts = [[]]

        for individual in population:
            # For each individual in the population, initialize the domination
            # count to 0 and the set of dominated solutions to empty.
            individual.domination_count = 0
            individual.dominated_solutions = []

            for other_individual in population:
                # For each pair of individuals, if one dominates the other,
                # update their domination count and dominated solutions.
                if individual.dominates(other_individual):
                    individual.dominated_solutions.append(other_individual)
                elif other_individual.dominates(individual):
                    individual.domination_count += 1

            # If an individual is not dominated by any other, it belongs to their
            # first front.
            if individual.domination_count == 0:
                individual.rank = 0
                population.fronts[0].append(individual)

        # Generate the rest of the fronts.
        i = 0
        while len(population.fronts[i]) > 0:
            temp = []
            for individual in population.fronts[i]:
                for other_individual in individual.dominated_solutions:
                    other_individual.domination_count -= 1
                    # If an individual is dominated by exactly i individuals,
                    # it belongs to the i-th front.
                    if other_individual.domination_count == 0:
                        other_individual.rank = i + 1
                        temp.append(other_individual)

            i = i + 1
            population.fronts.append(temp)

        if not population.fronts:
            print("Warning: No fronts were created.")
            population.fronts = [[ind for ind in population]]

        # 空のフロントを削除
        population.fronts = [front for front in population.fronts if front]

        print(f"Number of fronts: {len(population.fronts)}")
        print(f"Sizes of fronts: {[len(front) for front in population.fronts]}")

        return population.fronts


    #def calculate_crowding_distance(self, front):
    #    """
    #    Calculates the crowding distance for each individual in the front.
    #    The crowding distance is a measure of how close an individual is to its
    #    neighbors.
    #    """
    #    if len(front) > 0:
    #        solutions_num = len(front)
    #        for individual in front:
    #            individual.crowding_distance = 0

    #        for m in range(len(front[0].objectives)):
    #            front.sort(key=lambda individual: individual.objectives[m])

    #            # frontの両端の混雑距離はinfなので、大きな数値をここでは
    #            # セットしているのだと思われる
    #            front[0].crowding_distance = 10 ** 9 # float('inf')
    #            front[solutions_num - 1].crowding_distance = 10 ** 9 # float('inf')

    #            m_values = [individual.objectives[m] for individual in front]
    #            scale = max(m_values) - min(m_values)
    #            if scale == 0: scale = 1
    #            for i in range(1, solutions_num - 1):
    #                front[i].crowding_distance +=\
    #                    (front[i + 1].objectives[m] - front[i - 1].objectives[m]) / scale


    #def crowding_operator(self, individual, other_individual):
    #    """
    #    Compares two individuals based on their rank and crowding distance. It
    #    is used in the selection process to choose which individual will be kept
    #    in the population.

    #    :return: 1 if the first individual is better, -1 otherwise.
    #    """
    #    # If the first individual's  rank is lower or (the ranks are equal and
    #    # the first individual's crowding distance is larger)
    #    if (individual.rank < other_individual.rank) or \
    #            ((individual.rank == other_individual.rank) and (
    #                individual.crowding_distance > other_individual.crowding_distance)):
    #        return 1
    #    else:
    #        return -1


    def create_children(self, population):
        """
        Creates a new population of children for the next generation.
        Each child is created by crossover and mutation operations on two parentes
        selected from the population.

        :return: The new population of children.
        """
        children = []
        while len(children) < len(population):
            parent1 = self.__tournament(population)
            parent2 = parent1
            while parent1 == parent2:
                # parent1とparent2を別の個体にしたい、ということかな？
                parent2 = self.__tournament(population)
            child1, child2 = self.__crossover(parent1, parent2)
            self.__mutate(child1)
            self.__mutate(child2)
            self.problem.calculate_objectives(child1)
            self.problem.calculate_objectives(child2)
            children.append(child1)
            children.append(child2)
        return children


    def generate_reference_points(self, num_objectives, num_points):
        """
        NSGA-III用の参照点を生成する。

        :param num_objectives: 目的関数の数
        :param num_points: 生成する参照点の数(近似)
        :return: 生成された参照点のリスト 
        """
        def generate_recursive(ref_points, ref_point, left, total, index):
            """
            再帰的に参照点を生成する補助関数
            """
            if index == num_objectives - 1:
                ref_point[index] = left / total
                ref_points.append(ref_point[:])
            else:
                for i in range(left + 1):
                    ref_point[index] = i / total
                    generate_recursive(ref_points, ref_point, left - i, total, index + 1)

        ref_points = []
        initial_point = [0] * num_objectives
        generate_recursive(ref_points, initial_point, num_points, num_points, 0)
        print("Generated reference points shape: ", np.array(ref_points).shape)
        return np.array(ref_points)

    def associate_to_reference_point(self, population, reference_points):
        """
        個体群の各個体を最も近い参照点に関連づける

        :param population: 個体群
        :param reference_points: 参照点のリスト
        """
        print("Population size: ", len(population))
        print("Number of reference points: ", reference_points.shape)

        # 目的関数値を正則化する
        normalized_objectives = self.normalize_objectives(population)
        print("Normalized objectives shape:", normalized_objectives.shape)

        for i, individual in enumerate(population):
            print(f"Individual {i} objectives shape: ", np.array(individual.objectives).shape)
            print(f"Normalized objectives[{i}] shape: ", normalized_objectives[i].shape)
            print(f"Reference points shape: ", reference_points.shape)

            # 各個体と全ての参照点との距離を計算する
            distances = np.linalg.norm(normalized_objectives[i] - reference_points, axis=1)

            # 最も近い参照点のインデックスを個体に関連付ける
            individual.associated_ref_point = np.argmin(distances)

            # 最も近い参照点までの垂直距離を計算して保存する
            individual.perpendicular_distance = distances[individual.associated_ref_point]

    def normalize_objectives(self, population):
        """
        個体群の目的関数値を正規化する

        :param population: 個体群
        :return: 正規化された目的関数値の配列
        """
        # 全個体の目的関数値を抽出する
        objectives = np.array([ind.objectives for ind in population])
        print("Original objectives shape: ", objectives.shape)

        # 各目的関数の最小値と最大値を計算する
        min_values = np.min(objectives, axis=0)
        max_values = np.max(objectives, axis=0)

        # 目的関数値を0-1の範囲に正規化する
        normalized = (objectives - min_values) / (max_values - min_values + 1e-10)
        print("Normalized objectives shape: ", normalized.shape)
        return normalized

    def select_population_nsga3(self, population, num_individuals):
        """
        NSGA-IIIの選択メカニズムを使用して次世代の個体を選択する

        :param population: 現在の個体群
        :param num_individuals: 選択する個体の数
        :return: 選択された個体のリスト
        """
        fronts = self.fast_nondominated_sort(population)

        print(f"Number of fronts: {len(fronts)}")
        print(f"Sizes of fronts: {[len(front) for front in fronts]}")

        if not fronts:
            print("Error: No fronts were returned by fast_nondominated_sort")
            # フォールバック: 現在の個体をそのまま返す
            selected_population = Population()
            selected_population.extend(population.population[:num_individuals])
            return selected_population

        next_population = []
        front_index = 0

        # フロントを順番に追加していく
        while front_index < len(fronts) and \
                len(next_population) + len(fronts[front_index]) <= num_individuals:
            next_population.extend(fronts[front_index])
            front_index += 1

        # 最後のフロントから個体を選択する必要がある場合
        if len(next_population) < num_individuals and front_index < len(fronts):
            last_front = fronts[front_index]
            self.associate_to_reference_point(last_front, self.reference_points)

            # ニッチング処理を行い、最後のフロントから個体を選択する
            selected = self.niching(last_front, num_individuals - len(next_population))
            next_population.extend(selected)

        print(f"Selected population size: {len(next_population)}")

        # 選択された個体数が足りない場合、ランダムに個体を追加する
        if (len(next_population) < num_individuals):
            remaining = random.sample(population.population,
                                      num_individuals - len(next_population))
            next_population.extend(remaining)
            print(f"Added {len(remaining)} random individuals to meet population size")

        # Population オブジェクトを生成して返す
        selected_population = Population()
        selected_population.extend(next_population)

        return selected_population

    def niching(self, last_front, k):
        """
        ニッチング処理を行い、最後のフロントから個体を選択する

        :param last_front: 最後のフロントの個体リスト
        :param k: 選択する個体の数
        :return: 選択された個体のリスト
        """
        selected = []
        reference_point_counts = np.zeros(len(self.reference_points))

        # 各参照点に関連付けられた個体数をカウント
        for ind in last_front:
            reference_point_counts[ind.associated_ref_point] += 1

        while len(selected) < k:
            # 最も個体数の少ない参照点を選択
            min_count_ref_point = np.argmin(reference_point_counts)

            # 選択した参照点に関連付けられた個体を抽出
            associated_individuals =\
                [ind for ind in last_front if ind.associated_ref_point == min_count_ref_point]

            if associated_individuals:
                # 最も近い個体を選択
                chosen = min(associated_individuals, key=lambda ind: ind.perpendicular_distance)
                selected.append(chosen)
                last_front.remove(chosen)

                # 選択した個体の参照点のカウントを更新する
                reference_point_counts[min_count_ref_point] += 1
            else:
                # 関連付けられた個体が無い場合、その参照点を除外する
                reference_point_counts[min_count_ref_point] = np.inf

        return selected

    def __crossover(self, individual1, individual2):
        """
        Performs crossover operation on two individuals to create two children.
        The features of the children are a combination of the features of the parents.

        :return: The two children.
        """
        child1 = self.problem.generate_individual()
        child2 = self.problem.generate_individual()
        num_of_features = len(child1.features)
        genes_indexes = range(num_of_features)
        for i in genes_indexes:
            beta = self.__get_beta()
            x1 = (individual1.features[i] + individual2.features[i]) / 2
            x2 = abs((individual1.features[i] - individual2.features[i]) / 2)
            child1.features[i] = x1 + beta * x2
            child2.features[i] = x1 - beta * x2
        return child1, child2

    def __simulated_binary_crossover(
        self,
        individual1: Individual, 
        individual2: Individual) -> tuple[Individual, Individual]:
        """
        Simulated binary crossover(SBX)を行うメソッドです。

        Parameters:
            individual1 (Individual) : 親1
            individual2 (Individual) : 親2

        Returns:
            tupele:
                child1 (Individual) : 子1
                child2 (Individual) : 子2
        """
        child1 = self.problem.generate_individual()
        child2 = self.problem.generate_individual()
        num_of_featrues = len(child1.features)
        genes_indexes = range(num_of_features)
        for i in genes_indexes:
            beta = self.__get_beta()
            x1 = (individual1.features[i] + individual2.features[i]) / 2
            x2 = abs((individual1.features[i] - individual2.features[i]) / 2)
            child1.features[i] = x1 + beta * x2
            child2.features[i] = x1 - beta * x2
        return child1, child2


    def __unimodal_normal_distribution_crossover(
        self,
        parent1: Individual,
        parent2: Individual,
        parent3: Individual,
        sigma_xi: float = 0.5,
        sigma_eta: float = 0.35) -> tuple[Individual, Individual]:

        """UNDX

        Unimodal normal distribution crossover (UNDX)を行うメソッドです。
        親として3個体を引数として受け取り、2つの子個体を生成します。

        Parameters
        ----------
            parent1 : Individual
                親1
            parent2 : Individual
                親2
            parent3 : Individual
                親3
            sigma_xi : float
                正規分布の標準偏差
            sigma_eta : float
                正規分布の標準偏差

        Returns
        -------
            child1 : Individual
                parent1, 2, 3から生成された子個体1
            child2 : Individual
                parent1, 2, 3から生成された子個体1
        """
        # 2親個体の中点を計算する
        middle_of_parents = (parent1 + parent2) / 2

        # 2親個体を結ぶベクトルを計算する
        d1 = parent1 - parent2

        # 3番目の親個体と中点との差分ベクトルを計算する
        d2 = parent3 - middle_of_parents

        # d1を正規化する
        d1_norm = d1 / np.linalg.norm(d1)

        # d2からd1方向成分を取り除く
        d2 -= np.dot(d2, d1_norm) * d1_norm

        # 子個体を2つ生成する
        child1 = middle_of_parents \
            + np.random.normal(0, sigma_xi) * d1 / 2 \
            + np.random.normal(0, sigma_eta) * d2
        child2 = middle_of_parents \
            - np.random.normal(0, sigma_xi) * d1 / 2 \
            + np.random.normal(0, sigma_eta) * d2

        return child1, child2


    def __blend_crossover_alpha(
        self,
        parent1: Individual,
        parent2: Individual,
        alpha: float = 0.5) -> tuple[Individual, Individual]:
        """ BLX-alpha

        Blend Crossover (BLX-alpha)を行うメソッドです。

        Parameters
        ----------
        parent1 : Individual
        parent2 : Individual

        Returns
        -------
        child1 : Individual
            parent1とparent2から生成された子個体1
        child2 : Individual
            parent1とparent2から生成された子個体2
        """
        child1 = np.empty_like(parent1)
        child2 = np.empty_like(parent2)

        for i in range(len(parent1)):
            d = np.abs(parent1[i] - parent2[i])
            lower_bound = np.min([parent1[i], parent2[i]]) - alpha * d
            upper_bound = np.max([parent1[i], parent2[i]]) + alpha * d
            child1[i] = np.random.uniform(lower_bound, upper_bound)
            child2[i] = np.random.uniform(lower_bound, upper_bound)

        return child1, child2


    def __simplex_crossover(
        self,
        parents: List[Individual],
        epsilon: float) -> tuple[Individual, Individual]:
        """SPX

        Simplex crossoverを行うメソッドです。

        Parameters
        ----------
        parents : list(Individual)
        epsilon : float
            拡大率

        Returns
        -------
        """
        pass



    def __get_beta(self):
        """
        Calculates the beta value used in the crossover operation.
        The beta value determines how much influence each parent has on the child.

        :return: The beta value.
        """
        u = random.random()
        if u <= 0.5:
            return (2 * u) ** (1 / (self.crossover_param + 1))
        return (2 * (1 - u)) ** (-1 / (self.crossover_param + 1))

    def __mutate(self, child):
        """
        Performs mutation operation on a child. The features of the child are
        randomly changed to introduce diversity in the population.
        """
        num_of_features = len(child.features)
        for gene in range(num_of_features):
            u, delta = self.__get_delta()

            if u < 0.5:
                child.features[gene] +=\
                    delta * (child.features[gene] - self.problem.variables_range[gene][0])
            else:
                child.features[gene] +=\
                    delta * (self.problem.variables_range[gene][1] - child.features[gene])

            if child.features[gene] < self.problem.variables_range[gene][0]:
                child.features[gene] = self.problem.variables_range[gene][0]

            elif child.features[gene] > self.problem.variables_range[gene][1]:
                child.features[gene] = self.problem.variables_range[gene][1]

    def __get_delta(self):
        """
        Calculates the delta value used in the mutation operation. The delta
        value determines how much a feature is changed during mutation.

        :return: The delta value.
        """
        u = random.random()
        if u < 0.5:
            return u, (2 * u) ** (1 / (self.mutation_param + 1)) - 1
        return u, 1 - (2 * (1 - u)) ** (1 / (self.mutation_param + 1))

    def __tournament(self, population):
        """
        Performs tournament selection on the population. A number of individuals
        are randomly selected from the population, and the best one is chosen
        based on their rank and crowding distance.

        :return: The chosen individual.
        """
        participants = random.sample(population.population,
                                     self.num_of_tour_particips)
        best = None
        for participant in participants:
            if best is None or (
                self.crowding_operator(participant, best) == 1 and
                    self.__choose_with_prob(self.tournament_prob)):
                best = participant

        return best

    def __choose_with_prob(self, prob):
        """
        Makes a decision based on a probability. This is used in the tournament
        selection process to decide whether to choose an individual.

        :return: True if the decision is made, False otherwise.
        """
        if random.random() <= prob:
            return True
        return False
